#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# xml - Manage bits and pieces of XML files
#
# Copyright 2014, Red Hat, Inc.
# Tim Bielawa <tbielawa@redhat.com>
# Magnus Hedemark <mhedemar@redhat.com>
#
# This software may be freely redistributed under the terms of the GNU
# general public license version 2.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.


######################################################################
# Copied the Nagios module over so we have a starting template
######################################################################



DOCUMENTATION = '''
---
module: xml
short_description: Manage bits and pieces of XML files
description:
  - A CRUD-like interface to managing bits of XML flies. You might also be interested in a brief tutorial, U(http://www.w3schools.com/xpath/).
version_added: "1.0"
options:
  file:
    description:
      - Path to the file to operate on. File must exist ahead of time.
    required: true
    default: null
    choices: []
  xpath:
    description:
      - A valid XPath expression describing the item(s) you want to manipulate. Operates on the document root, C(/), by default.
    required: false
    default: /
    choices: []
  ensure:
    description:
      - Set or remove an element
    required: false
    default: present
    choices:
      - "absent"
      - "present"
  value:
    description:
      - Desired state of the selected element/attribute. Either a string, or to unset a value, the Python C(None) keyword (YAML Equivalent, C(null)).
    required: false
    default: Elements default to no value (but present). Attributes default to an empty string.
    choices: []
  children:
    description:
      - 'Define the child-element(s) of a selected element. Child elements may be given in several forms: A single string (ex: C(children=ansible) to add an empty C(<ansible/>) child element), a single hash where the key is an element name and the value is the element value, or a list of a combination of strings and hashes.'
    required: false
    default: null
    choices: []
requirements:
    - The remote end must have the Python C(lxml) library installed
author: Tim Bielawa, Magnus Hedemark
'''

EXAMPLES = '''
#Given: an xml file (/foo/bar.xml):
#
#   <?xml version='1.0' encoding='UTF-8'?>
#   <business type="bar">
#       <name>Tasty Beverage Co.</name>
#       <beers>
#           <beer>Rochefort 10</beer>
#           <beer>St. Bernardus Abbot 12</beer>
#           <beer>Schlitz</beer>
#       </beers>
#       <rating subjective="true">10</rating>
#       <website>
#           <mobilefriendly />
#           <address>http://tastybeverageco.com</address>
#       </website>
#   </business>

# Remove the 'subjective' attribute of the rating element
- xml: file=/foo/bar.xml xpath=/business/rating/@subjective ensure=absent

# Set the rating to 11
- xml: file=/foo/bar.xml xpath=/business/rating value=11

# Add a phonenumber element to the business element
# Implicit 'mkdir -p' behavior where applicable (parent xml nodes created automatically)
- xml: file=/foo/bar.xml xpath=/business/phonenumber value=555-555-1234

# Add several more beers to the beers element, assuming a vars.yaml file with
#    new_beers:
#        - beer: "Old Rasputin"
#        - beer: "Old Motor Oil"
#        - beer: "Old Curmudgeon"
- xml: file=/foo/bar.xml xpath=/business/beers children={{ new_beers }}

# The same, but do it inline
- xml:
    file: /foo/bar.xml
    xpath: /business/beers
    children:
        - beer: "Old Rasputin"
        - beer: "Old Motor Oil"
        - beer: "Old Curmudgeon"

# Add a validxhtml element to the website element. Note that 'ensure'
# is 'present' by default, and 'value' defaults to null for
# elements. The result is something like <website><validxhtml />...</website>
- xml: file=/foo/bar.xml xpath=/business/website/validxhtml

# Add an empty validatedon attribute to the validxhtml element. This
# actually makes the last example redundant because of the implicit
# parent-node creation behavior. The result is something like
# <website><validxhtml validatedon='' />...</website>
xml: file=/foo/bar.xml xpath=/business/website/validxhtml/@validatedon

# Remove all children from the website element
- xml: file=/foo/bar.xml xpath=/business/website/* ensure=absent
'''
######################################################################

from lxml import etree
import os

def delete_xpath_target(tree, xpath, module):
    try:
        for node in tree.xpath(xpath):
            node.getparent().remove(node)
    except:
        abort("Couldn't delete xpath target: %s" % xpath, module)
    else:
        finish(tree, xpath, module)

def set_target_children(tree, xpath, children, module):
    pass

def set_target_attribute(tree, xpath, value, module):
    pass

def set_target_value(tree, xpath, value, module):
    pass

def children_to_nodes(tree, children, module):
    pass

def abort(msg, m):
    m.fail_json(msg=msg)

def finish(tree, xpath, m):
    # Serialize the results and quit
    result = etree.tostring(tree, pretty_print=True)
    open(m.params['file'], 'w').write(result)
    m.exit_json(changed=True,actions={"xpath": xpath, "ensure": m.params['ensure']})


def main():
    module = AnsibleModule(
        argument_spec=dict(
            file=dict(required=True),
            xpath=dict(required=False, default='/'),
            ensure=dict(required=False, default='present', choices=['absent', 'present']),
            value=dict(required=False, default=None),
            children=dict(required=False, default=None)
        ),
        supports_check_mode=True,
        mutually_exclusive = [['value','children']],
    )

    xml_file = module.params['file']
    xpath = module.params['xpath']
    ensure = module.params['ensure']
    value = module.params['value']
    children = module.params['children']

    ##################################################################
    # Check if the file exists
    # No: abort
    if not os.path.isfile(xml_file):
        module.fail_json(
            msg="The target XML file does not exist: %s" %
            xml_file)
    else:
        # Try to parse in the target XML file
        try:
            x = etree.parse(file(xml_file, 'r'))
        except etree.XMLSyntaxError, e:
            module.fail_json(
                msg="Error while parsing file: %s" %
                str(e))

    # module.fail_json(msg="OK. Well, etree parsed the xml file...")

    # module.exit_json(what_did={"foo": "bar"}, changed=True)

    ##################################################################
    # File exists:
    # Ensure:
    if ensure == 'absent':
        # - absent: delete xpath target
        delete_xpath_target(x, xpath, module)
        # Exit
    # - present: carry on

    ##################################################################
    # children && value both set?: should have already aborted by now
    ##################################################################

    ##################################################################
    # Children set?
    # Yes: Set children target
    set_target_children(xpath, children)

    # No?: Carry on

    ##################################################################
    # Is the xpath target an attribute selector?
    # Yes: Set the attribute, exit
    set_target_attribute(xpath, value)

    # No: Set the node value, exit
    set_target_value(xpath, value)



######################################################################
from ansible.module_utils.basic import *
main()
